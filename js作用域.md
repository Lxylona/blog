# js 作用域相关

**作用域**定义引擎如何查找一个变量以及在哪里查找变量的规则。
js 的作用域为词法作用域，也就是静态作用域，顾名思义，函数的作用域在函数声明的时候就已经确定了。

## 静态作用域和动态作用域的区别

**动态作用域**函数的作用域是调用的时候才决定的，和 js 的 this 很像。

```javascript
var value = 1;
function foo() {
  console.log(value);
}
function bar() {
  var value = 2;
  foo();
}
// 静态作用域打印 1, foo 内部 -> foo 声明的地方
// 动态作用域打印 2，foo 内部 -> foo 调用的地方
bar();
```

## 静态作用域链

简单讲就是一直沿着函数声明的地方往上，直到全局环境。
举个例子，下面例子中函数 c 的作用域链为 c -> b -> a -> 全局；d 的作用域链为 d -> a -> 全局。

```js
function a() {
  function b() {
    function c() {
      // 变量和函数查找顺序：c -> b -> a -> 全局
    }
  }
  function d() {
    // 变量和函数查找顺序：d -> a -> 全局
  }
}
```

## 闭包

如果理解了 js 的静态作用域和作用域链，应该很容易理解闭包。
我们无法在一个函数的外部引用该函数内部的变量和函数，因为该函数外部的环境的作用域链不包含该函数内部的变量和函数。
如果一定要在函数外部访问该函数内部的变量或函数，那我们可以想办法，把想要的变量或者函数添加进当前环境的作用域链内，闭包就应运而生了。
闭包的形式挺多的，最常见的形式就是函数返回内部变量，让外部的变量引用。

```javascript
function closureTest() {
  let a = { n: 2 };
  return a;
}
// 本来这里无法访问 a 的，但是 closureTest 返回了 a，外部用一个变量 b 来引用。
// 我认为这里就相当于把对象 { n: 2 } 添加进当前的作用域中。
let b = closureTest();
```

`setTimeout`也是一种闭包，它通过`setTimeout`的参数引用内部函数来完成。

```javascript
function closureTest() {
  let a = 10;
  // 该箭头函数最终在全局条件下执行，但是仍然可以使用 a
  // 因为该函数其实是内部函数，setTimeout 第一个参数引用了该函数，因此可以访问内部变量。
  setTimeout(() => {
    console.log(a);
  }, 300);
}
```

### 疑问：为什么在 JS 闭包中，外层函数执行完弹出调用栈后，还能保持变量的状态呢

函数执行完之后，会弹出执行栈，讲道理该函数对象就被销毁了，为什么闭包还能够使用内部的变量呢，内部的变量是怎么保存的呢？

先说结论：
一个函数拥有执行环境对象和变量对象这两个对象，执行环境对象定义了变量和函数，有权访问其他数据，保存在调用栈中。变量对象保存了这个函数的变量和函数，保存在堆中。执行环境对象的销毁和变量对象无关。因此函数出栈之后，也就是执行环境对象销毁之后，变量对象仍然可能存在内存中，所以还是可以保存变量的状态。

下面是详细版本：
其实，函数具有两个对象：执行环境对象、变量对象。其中，执行环境对象在**调用栈**中，变量对象在**堆**中。
每次**调用**函数的时候都会创建一个全新的函数执行环境对象，也就是调用栈上的对象。初始化执行环境对象的时候，会创建一个变量对象，**环境中所有定义的变量和函数都会保存在这个对象中**。然后初始化这个变量对象，然后确定 this 的指向。
注意，执行环境对象和变量对象之间没有亲属关系，它们两个是完全平等而且不相关的。
函数对象本身有一个作用域链，也就是函数声明的当前环境的作用域链。比如函数 b 在函数 a 中声明，那么 b 的函数对象的作用域链就是 a 的执行环境对象的作用域链。
执行环境对象有一个作用域链属性，当我们初始化一个执行环境对象的时候，它把函数对象自身的作用域链属性复制过来，然后把和自己对应的那个变量对象添加到这个作用域链的顶端，构成它自己的作用域链属性。之后函数对变量的查找就沿着这条作用域链了。
也就是说，调用函数的时候，涉及到了两个作用域链。一个是函数对象本身的，在函数声明的时候就有了的，直接复制了父函数执行环境对象的作用域链。第二个是自己执行环境对象的，比第一个多了自己的变量对象。
那么现在我们函数执行完毕，执行环境对象出栈，销毁。但是我们的变量对象并没有销毁，因为它还被别的变量引用着～只要被引用，就不会被销毁，这也是为什么会内存泄漏的原因。
