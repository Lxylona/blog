## 引言

在刷 leetcode 时，遇到了“两数相加”这道题，起先是先把链表转化为数值再相加，然后把结果转化为链表，提交的时候发现遇到大数结果就不准确了。打印出来发现是大数被转化为科学计数法，精度丢失导致的。

在 js 中有很多这种现象，特别恶心，像什么`0.1 + 0.2 === 0.30000000000000004`、`35.41 * 100 === 3540.9999999999995`......

为什么`0.1 + 0.2 === 0.30000000000000004`呢？

原因是 0.1 无法用二进制完整存储，因为 0.1 转化为二进制是无限循环小数：0.000110011001100110011（0011 无限循环）……

这是浮点数本身存在的弊端。那么对于无限位的浮点数，应该如何存储呢，截取其中几位小数呢？js 的 Number 采用的是 IEEE754 规范中 64 位双精度浮点数编码。

## IEEE754 规范

IEEE754 对于浮点数表示方式给出了一种定义。格式如下：

(-1)^S _ M _ 2^E

其中，S 为符号位，占 1bit，0 为正数，-1 为负数。

M 为有效位，1 < M < 2。

E 为指数位。

如果用 IEEE754 规范来表示 0.1，那么是：(-1)^1 _ 1.10011001100110011... _ 2^(-4).

IEEE754 规定，

1. 对于 32 位的单精度浮点数，最高的 1 位是符号位 S，接着的 8 位是指数 E，剩下的 23 位为有效数字 M。
2. 对于 64 位的双精度浮点数，最高的 1 位是符号位 S，接着的 11 位是指数 E，剩下的 52 位为有效数字 M。
3. 指数并不是直接存储的，中间的 8 位存储的是阶数（指数 + 偏置量， 单精度规定偏置量为 127， 双精度为 1023）。
4. 浮点数存储不存储小数点前的 1（因为肯定是 1），只存储小数点后的，不足的用 0 补全。

比如 0.15625 在单精度下的存储形式：（其中 0.15625 的阶数为 124， 8 位二进制表示为 01111100。）

![0.15625 的存储形式](https://github.com/Lxylona/blog/blob/master/images/precisionLoss1.png?raw=true)

对于 0.1 这种有效数字无限循环的数该如何截断，IEEE754 默认的舍入模式是：舍入到最接近且可以表示的值，当存在两个数一样接近时，取偶数值。

到这里已经能够理解为什么`0.1 + 0.2 === 0.30000000000000004`了，在内部，0.1 和 0.2 都会先转化为二进制再进行计算，而转化为二进制时 0.1 的精度已经丢失了，所以计算出的结果为 0.30000000000000004。

## 解决方案

只抛出问题不给解决方案就是耍流氓。

我们要保留精度，最简单的做法就是把小数转化为正数然后进行加减乘除再转化为小数。（当前前提是数值不是特别大，小数后位数不是特别多，不然变成科学计数法就尴尬了），具体代码详见参考文件[2]。

ps：之前一直用`toFixed()`来保留精度，`toFixed()`其实很坑:

```js
(1.3335).toFixed(3); // "1.333"
(1.33335).toFixed(4); // "1.3334"
```

## 参考文章

[1][深入理解 javascript 中的精度丢失](https://juejin.im/post/5b20cbb051882513ac20354f)

[2][js中小数四舍五入和浮点数的研究](http://caibaojian.com/js-tofixed.html)
